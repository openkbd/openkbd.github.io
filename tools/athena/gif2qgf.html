<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIF to QGF for Athena1800</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem 0;
            margin: 0;
            background-color: #f0f2f5;
        }
        .container, .preview-container {
            width: 90%;
            max-width: 600px;
            padding: 2rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            text-align: center;
            margin-bottom: 1.5rem;
        }
        h1, h3 { color: #333; margin-top: 0; }
        p { color: #666; margin-bottom: 1.5rem; }
        .controls { display: flex; flex-direction: column; gap: 1rem; align-items: center; }
        button {
            padding: 0.6rem 1.2rem; font-size: 1rem; border: none; border-radius: 5px;
            cursor: pointer; background-color: #007bff; color: white; transition: background-color 0.2s;
        }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .preview-container { border: 2px dashed #cccccc; }
        .preview-pair { display: flex; justify-content: space-around; gap: 1rem; align-items: center; }
        .preview-box { flex: 1; }
        .preview-box img, .preview-box canvas {
            max-width: 100%; max-height: 200px; border: 1px solid #ddd;
            border-radius: 4px; image-rendering: pixelated;
        }
        #frameCountDisplay { font-weight: bold; color: #333; margin-top: 1rem; margin-bottom: 0; }
        .frame-slider-control { margin-top: 1.5rem; }
        .hidden { display: none; }
        #gif-container { display: none; }
    </style>
</head>
<body>

    <div class="container">
        <h1>GIF to QGF for Athena1800</h1>
        <p>仅支持128x128的GIF。请注意用作打字和大小写，要小于31帧。其他的小于63帧。</p>
        <div class="controls">
            <input type="file" id="fileUploader" accept=".gif">
            <button id="saveButton" disabled>保存为 QGF</button>
        </div>
        <p>图片不会上传至互联网，仅在本地处理。</p>
    </div>
    
    <div id="previewArea" class="preview-container hidden">
        <h3>预览</h3>
        <p id="frameCountDisplay"></p>
        <div class="preview-pair">
            <div class="preview-box"><h4>原图</h4><img id="gifPreview" src="" alt="GIF Preview"></div>
            <div class="preview-box"><h4>RGB565 转换结果</h4><canvas id="rgb565PreviewCanvas"></canvas></div>
        </div>
        <div id="frameSliderControl" class="frame-slider-control hidden">
            <label for="frameSlider">预览帧: <span id="currentFrameLabel">1</span> / <span id="totalFramesLabel">1</span></label>
            <br>
            <input type="range" id="frameSlider" min="0" max="0" value="0" style="width: 80%;">
        </div>
    </div>

    <div id="gif-container"><img id="gifImage" /></div>

    <script>
        function loadScripts(urls, finalCallback) {
            const promises = urls.map(url => new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = resolve;
                script.onerror = () => reject(new Error(`无法加载脚本: ${url}`));
                document.head.appendChild(script);
            }));
            Promise.all(promises).then(finalCallback).catch(console.error);
        }
        
        loadScripts([
            'https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.min.js',
            'https://cdn.jsdelivr.net/npm/libgif@0.0.3/libgif.min.js'
        ], runApp);

        function runApp() {
            const uploader = document.getElementById('fileUploader');
            const saveButton = document.getElementById('saveButton');
            const previewArea = document.getElementById('previewArea');
            const gifPreview = document.getElementById('gifPreview');
            const frameCountDisplay = document.getElementById('frameCountDisplay');
            const gifImage = document.getElementById('gifImage');
            const rgb565PreviewCanvas = document.getElementById('rgb565PreviewCanvas');
            const frameSliderControl = document.getElementById('frameSliderControl');
            const frameSlider = document.getElementById('frameSlider');
            const currentFrameLabel = document.getElementById('currentFrameLabel');
            const totalFramesLabel = document.getElementById('totalFramesLabel');

            let processedFramesData = [];
            let gifInfo = {};
            let originalFilename = '';

            uploader.addEventListener('change', handleFileSelect);
            saveButton.addEventListener('click', saveRgb565Qgf);
            frameSlider.addEventListener('input', handleSliderChange);
            
            function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) { return; }
                saveButton.disabled = true;
                frameSliderControl.classList.add('hidden');
                previewArea.classList.add('hidden');
                originalFilename = file.name;

                const reader = new FileReader();
                reader.readAsArrayBuffer(file);
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    try {
                        const u8array = new Uint8Array(arrayBuffer);
                        const gifReader = new GifReader(u8array);
                        const frameCount = gifReader.numFrames();
                        const delays = [];
                        for (let i = 0; i < frameCount; i++) {
                            delays.push(gifReader.frameInfo(i).delay * 10);
                        }
                        gifInfo = { frameCount, delays, width: gifReader.width, height: gifReader.height };
                        
                        if (gifInfo.width !== 128 || gifInfo.height !== 128) {
                            alert(`上传的GIF尺寸 (${gifInfo.width}x${gifInfo.height}) 不符合要求，必须是 128x128 像素。`);
                            uploader.value = '';
                            return;
                        }
                        
                        frameCountDisplay.textContent = `总帧数: ${frameCount} | 初始帧间隔: ${delays[0] || 0} ms`;
                    } catch (error) {
                        alert("无法解析GIF元数据。文件可能已损坏。"); return;
                    }

                    const blob = new Blob([arrayBuffer], { type: 'image/gif' });
                    const objectURL = URL.createObjectURL(blob);
                    gifPreview.src = objectURL;
                    gifImage.src = objectURL;
                    previewArea.classList.remove('hidden');

                    const superGif = new SuperGif({ gif: gifImage });
                    superGif.load(() => {
                        processAllFramesToRgb565(superGif);
                    });
                };
            }
            
            function processAllFramesToRgb565(superGif) {
                processedFramesData = []; 
                const { frameCount, width, height } = gifInfo;
                for (let i = 0; i < frameCount; i++) {
                    superGif.move_to(i);
                    const frameCanvas = superGif.get_canvas();
                    const rgbaPixels = frameCanvas.getContext('2d').getImageData(0, 0, width, height).data;
                    const frameRgb565Data = new Uint16Array(width * height);
                    let rgb565Index = 0;
                    for (let p = 0; p < rgbaPixels.length; p += 4) {
                        const r = rgbaPixels[p], g = rgbaPixels[p + 1], b = rgbaPixels[p + 2];
                        frameRgb565Data[rgb565Index++] = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
                    }
                    processedFramesData.push(frameRgb565Data);
                }
                
                saveButton.disabled = false;
                setupFrameSlider();
                renderRgb565Frame(0);
            }
            
            function renderRgb565Frame(frameIndex) {
                if (!processedFramesData[frameIndex]) return;
                const { width, height } = gifInfo;
                const frameData = processedFramesData[frameIndex];
                const ctx = rgb565PreviewCanvas.getContext('2d');
                rgb565PreviewCanvas.width = width;
                rgb565PreviewCanvas.height = height;
                const imageData = ctx.createImageData(width, height);
                const rgbaPixels = imageData.data;
                for (let i = 0; i < frameData.length; i++) {
                    const rgb565 = frameData[i];
                    let r = (rgb565 & 0b1111100000000000) >> 11, g = (rgb565 & 0b0000011111100000) >> 5, b = (rgb565 & 0b0000000000011111);
                    r = (r << 3) | (r >> 2); g = (g << 2) | (g >> 4); b = (b << 3) | (b >> 2);
                    const pixelIndex = i * 4;
                    rgbaPixels[pixelIndex] = r; rgbaPixels[pixelIndex + 1] = g; rgbaPixels[pixelIndex + 2] = b; rgbaPixels[pixelIndex + 3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);
            }

            function setupFrameSlider() {
                const frameCount = gifInfo.frameCount;
                if (frameCount > 0) {
                    frameSlider.max = frameCount > 1 ? frameCount - 1 : 0;
                    frameSlider.value = 0;
                    totalFramesLabel.textContent = frameCount;
                    currentFrameLabel.textContent = 1;
                    frameSliderControl.classList.remove('hidden');
                }
            }

            function handleSliderChange(event) {
                const frameIndex = parseInt(event.target.value, 10);
                currentFrameLabel.textContent = frameIndex + 1;
                renderRgb565Frame(frameIndex);
                if (gifImage.superGif) gifImage.superGif.move_to(frameIndex);
            }

            function saveRgb565Qgf() {
                if (!processedFramesData || processedFramesData.length === 0) { alert("没有可保存的数据！"); return; }
                
                console.log(`开始构建带完整主文件头的 QGF 动画文件...`);

                const PER_FRAME_HEADER_TEMPLATE = [
                    0x02, 0xFD, 0x06, 0x00, 0x00, 0x08, 0x00, 0x00,
                    0xFF, 0x00, 0x00, 0x05, 0xFA, 0x00, 0x80, 0x00
                ];
                const PER_FRAME_HEADER_SIZE = PER_FRAME_HEADER_TEMPLATE.length;
                const framePixelDataSize = gifInfo.width * gifInfo.height * 2;
                const singleFrameBlockSize = PER_FRAME_HEADER_SIZE + framePixelDataSize;
                const masterHeaderSize = (gifInfo.frameCount * 4) + 28;
                const totalFileSize = masterHeaderSize + (singleFrameBlockSize * gifInfo.frameCount);

                const buffer = new ArrayBuffer(totalFileSize);
                const dataView = new DataView(buffer);
                let byteOffset = 0;

                const fixedMasterHeader = [0x00, 0xFF, 0x12, 0x00, 0x00, 0x51, 0x47, 0x46, 0x01];
                fixedMasterHeader.forEach(byte => dataView.setUint8(byteOffset++, byte));
                
                dataView.setUint32(byteOffset, totalFileSize, true); byteOffset += 4;
                dataView.setUint32(byteOffset, ~totalFileSize, true); byteOffset += 4;
                dataView.setUint16(byteOffset, gifInfo.width, true); byteOffset += 2;
                dataView.setUint16(byteOffset, gifInfo.height, true); byteOffset += 2;
                dataView.setUint16(byteOffset, gifInfo.frameCount, true); byteOffset += 2;
                dataView.setUint8(byteOffset++, 0x01); dataView.setUint8(byteOffset++, 0xFE);

                const tableSize = gifInfo.frameCount * 4;
                dataView.setUint8(byteOffset++, tableSize & 0xFF);
                dataView.setUint8(byteOffset++, (tableSize >> 8) & 0xFF);
                dataView.setUint8(byteOffset++, (tableSize >> 16) & 0xFF);

                for (let i = 0; i < gifInfo.frameCount; i++) {
                    const frameOffset = masterHeaderSize + (i * singleFrameBlockSize);
                    dataView.setUint32(byteOffset, frameOffset, true);
                    byteOffset += 4;
                }
                
                byteOffset = masterHeaderSize;
                for (let i = 0; i < gifInfo.frameCount; i++) {
                    const blockStartOffset = byteOffset;
                    
                    for (const byte of PER_FRAME_HEADER_TEMPLATE) {
                        dataView.setUint8(byteOffset++, byte);
                    }
                    
                    // **核心修正：将延迟写入第10和11字节（索引9）**
                    const delay = gifInfo.delays[i] || 0;
                    // 计算要覆写的绝对位置：当前块的起始位置 + 9
                    const delayWritePosition = blockStartOffset + 9;
                    dataView.setUint16(delayWritePosition, delay, true); // true for Little-Endian

                    const frameData = processedFramesData[i];
                    for (const pixel of frameData) {
                        dataView.setUint16(byteOffset, pixel, false);
                        byteOffset += 2;
                    }
                    console.log(`已写入第 ${i+1} 帧的数据块 (延迟: ${delay}ms)。`);
                }
                
                const blob = new Blob([buffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const baseName = originalFilename.replace(/\.[^/.]+$/, "");
                link.download = `${baseName}_gif.qgf`;
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                console.log(`文件 ${link.download} (总大小: ${totalFileSize}字节) 已生成并开始下载。`);
            }
        }
    </script>

</body>
</html>